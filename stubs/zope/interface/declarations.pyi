from collections.abc import Iterator
from typing import TypeVar, overload
from typing_extensions import Self
from weakref import WeakValueDictionary

from zope.interface.interface import InterfaceClass, NameAndModuleComparisonMixin, Specification, SpecificationBase
from zope.interface.interfaces import ISpecification

__all__: list[str] = []

_T = TypeVar("_T")

BuiltinImplementationSpecifications: dict[type[object], Implements]

class named:
    name: str
    def __init__(self, name: str) -> None: ...
    def __call__(self, ob: _T) -> _T: ...

class implementer:
    interfaces: tuple[InterfaceClass | Declaration, ...]
    def __init__(self, *interfaces: InterfaceClass | Declaration) -> None: ...
    def __call__(self, ob: _T) -> _T: ...

class Declaration(Specification):
    def __init__(self, *bases: InterfaceClass | Declaration) -> None: ...
    def __contains__(self, interface: InterfaceClass) -> bool: ...
    def __iter__(self) -> Iterator[InterfaceClass]: ...
    def flattened(self) -> Iterator[InterfaceClass]: ...
    def __sub__(self, other: ISpecification) -> Declaration: ...
    def __add__(self, other: ISpecification) -> Declaration: ...
    __radd__ = __add__

class Implements(NameAndModuleComparisonMixin, Declaration):
    __name__: str
    inherit: type[object] | None
    declared: tuple[InterfaceClass | Declaration, ...]
    @classmethod
    def named(cls, name: str, *bases: InterfaceClass | Declaration) -> Self: ...
    def __reduce__(self) -> tuple[object, tuple[type[object] | None]]: ...

def implementedBy(cls: type[object]) -> Declaration: ...
def classImplementsOnly(cls: type[object], *interfaces: InterfaceClass | Declaration) -> None: ...
def classImplements(cls: type[object], *interfaces: InterfaceClass | Declaration) -> None: ...
def classImplementsFirst(cls: type[object], iface: InterfaceClass | Declaration) -> None: ...

class implementer_only:
    interfaces: tuple[InterfaceClass | Declaration, ...]
    def __init__(self, *interfaces: InterfaceClass | Declaration) -> None: ...
    def __call__(self, ob: _T) -> _T: ...

class Provides(Declaration):
    def __init__(self, cls: type[object], *interfaces: InterfaceClass | Implements) -> None: ...
    def __get__(self, inst: None, cls: type[object]) -> Self: ...
    def __reduce__(self) -> tuple[type[Provides], tuple[type[object], ...]]: ...

ProvidesClass = Provides
InstanceDeclarations: WeakValueDictionary[tuple[InterfaceClass | Implements, ...], ProvidesClass]

def directlyProvides(object: object, *interfaces: InterfaceClass | Declaration) -> None: ...
def alsoProvides(object: object, *interfaces: InterfaceClass | Declaration) -> None: ...
def noLongerProvides(object: object, interface: InterfaceClass | Declaration) -> None: ...

class ClassProvidesBase(SpecificationBase):
    @overload
    def __get__(self, inst: None, cls: type[object] | None = None) -> Self: ...
    @overload
    def __get__(self, inst: object, cls: type[object] | None = None) -> Declaration: ...

class ClassProvides(Declaration, ClassProvidesBase):
    def __init__(self, cls: type[object], metacls: type[object], *interfaces: InterfaceClass) -> None: ...
    def __reduce__(self) -> tuple[type[Self], tuple[type[object], ...]]: ...

def directlyProvidedBy(object: object) -> Declaration: ...

class provider:
    interfaces: tuple[InterfaceClass | Declaration, ...]
    def __init__(self, *interfaces: InterfaceClass | Declaration) -> None: ...
    def __call__(self, ob: _T) -> _T: ...

def moduleProvides(*interfaces: InterfaceClass | Declaration) -> None: ...
def ObjectSpecification(direct: InterfaceClass | Declaration, cls: type[object]) -> Provides: ...
def getObjectSpecification(ob: object) -> Declaration: ...
def providedBy(ob: object) -> Declaration: ...

class ObjectSpecificationDescriptor:
    def __get__(self, inst: object, cls: type[object] | None = None) -> Declaration: ...

objectSpecificationDescriptor: ObjectSpecificationDescriptor
