from collections.abc import Callable, Collection, Iterable, Iterator, Sequence
from typing import Any, TypeVar, overload
from typing_extensions import TypeAlias, Self
from weakref import ref

from zope.interface.declarations import implementer
from zope.interface.exceptions import Invalid
from zope.interface.interface import _SignatureInfo, Interface

__all__ = ["ComponentLookupError", "IAdapterRegistration", "IAdapterRegistry", "IAttribute", "IComponentLookup", "IComponentRegistry", "IComponents", "IDeclaration", "IElement", "IHandlerRegistration", "IInterface", "IInterfaceDeclaration", "IMethod", "IObjectEvent", "IRegistered", "IRegistration", "IRegistrationEvent", "ISpecification", "ISubscriptionAdapterRegistration", "IUnregistered", "IUtilityRegistration", "Invalid", "ObjectEvent", "Registered", "Unregistered"]

_T = TypeVar("_T")
_I = TypeVar('_I', bound=Interface)

_DefaultT = TypeVar("_DefaultT")
_CallableT = TypeVar("_CallableT", bound=Callable[..., Any])
# NOTE: This is technically broader than what the interface documentation calls
#       for, but since the default implementation supports this it seems like a
#       good idea to be this broad as well, even if this would mark some technically
#       valid implementations as invalid
_Adapts: TypeAlias = Sequence[ISpecification | type[object] | None]

class IElement(Interface):
    def getTaggedValue(tag: object) -> Any: ...
    @overload
    def queryTaggedValue(tag: object, default: None = None) -> Any | None: ...
    @overload
    def queryTaggedValue(tag: object, default: _T) -> Any | _T: ...
    def getTaggedValueTags() -> Collection[Any]: ...
    def setTaggedValue(tag: object, value: object) -> None: ...
    def getDirectTaggedValue(tag: object) -> Any: ...
    @overload
    def queryDirectTaggedValue(tag: object, default: None = None) -> Any | None: ...
    @overload
    def queryDirectTaggedValue(tag: object, default: _T) -> Any | _T: ...
    def getDirectTaggedValueTags() -> Collection[Any]: ...

class IAttribute(IElement):
    interface: IInterface

class IMethod(IAttribute):
    def getSignatureInfo() -> _SignatureInfo: ...
    def getSignatureString() -> str: ...

class ISpecification(Interface):
    __bases__: tuple[ISpecification, ...]
    __sro__: tuple[ISpecification, ...]
    __iro__: tuple[IInterface, ...]
    def providedBy(object: object) -> bool: ...
    def implementedBy(class_: type[object]) -> bool: ...
    def isOrExtends(other: ISpecification) -> bool: ...
    def extends(other: ISpecification, strict: bool = True) -> bool: ...
    # FIXME: Can we make Self work in interfaces?
    def weakref(callback: Callable[[ref[Any]], Any] | None = None) -> ref[Any]: ...
    @overload
    def get(name: str, default: None = None) -> IAttribute | None: ...
    @overload
    def get(name: str, default: _T) -> IAttribute | _T: ...

class IInterface(ISpecification, IElement):
    def names(all: bool = False) -> Collection[str]: ...
    def namesAndDescriptions(all: bool = False) -> Collection[tuple[str, IAttribute]]: ...
    def __getitem__(name: str) -> IAttribute: ...
    def direct(name: str) -> IAttribute | None: ...
    def validateInvariants(obj: object, errors: list[Invalid] | None = None) -> None: ...
    def __contains__(name: str) -> bool: ...
    def __iter__() -> Iterator[str]: ...
    __module__: str

class IDeclaration(ISpecification):
    def __contains__(interface: IInterface) -> bool: ...
    def __iter__() -> Iterator[IInterface]: ...
    def flattened() -> Iterator[IInterface]: ...
    def __sub__(interfaces: IInterface) -> IDeclaration: ...
    def __add__(interfaces: IInterface) -> IDeclaration: ...

class IInterfaceDeclaration(Interface):
    Interface: IInterface
    def taggedValue(key: object, value: object) -> None: ...
    def invariant(checker_function: Callable[[Any], object]) -> None: ...
    def interfacemethod(method: _CallableT) -> Self: ...
    def providedBy(ob: object) -> IDeclaration: ...
    def implementedBy(class_: type[object]) -> IDeclaration: ...
    def classImplements(class_: type[object], *interfaces: IInterface | IDeclaration) -> None: ...
    def classImplementsFirst(cls: type[object], interface: IInterface | IDeclaration) -> None: ...
    def implementer(*interfaces: IInterface | IDeclaration) -> Callable[[_T], _T]: ...
    def classImplementsOnly(class_: type[object], *interfaces: IInterface | IDeclaration) -> None: ...
    def implementer_only(*interfaces: IInterface | IDeclaration) -> Callable[[_T], _T]: ...
    def directlyProvidedBy(object: object) -> IDeclaration: ...
    def directlyProvides(object: object, *interfaces: IInterface | IDeclaration) -> IDeclaration: ...
    def alsoProvides(object: object, *interfaces: IInterface | IDeclaration) -> None: ...
    def noLongerProvides(object: object, interface: IInterface | IDeclaration) -> None: ...
    def provider(*interfaces: IInterface | IDeclaration) -> Callable[[_T], _T]: ...
    def moduleProvides(*interfaces: IInterface | IDeclaration) -> None: ...
    def Declaration(*interfaces: IInterface | IDeclaration) -> IDeclaration: ...

class IAdapterRegistry(Interface):
    @overload
    def register(required: Sequence[ISpecification | None], provided: IInterface, name: str, value: None) -> None: ...
    @overload
    def register(required: Sequence[ISpecification | None], provided: type[_T], name: str, value: Callable[..., _T]) -> None: ...
    def registered(required: Sequence[ISpecification | None], provided: type[_T], name: str = "") -> _T | None: ...
    @overload
    def lookup(required: Sequence[ISpecification | None], provided: type[_T], name: str = "", default: None = None) -> Callable[..., _T] | None: ...
    @overload
    def lookup(required: Sequence[ISpecification | None], provided: type[_T], name: str = "", *, default: _DefaultT) -> Callable[..., _T] | _DefaultT: ...
    @overload
    def lookup(required: Sequence[ISpecification | None], provided: type[_T], name: str, default: _DefaultT) -> Callable[..., _T] | _DefaultT: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], provided: type[_T], name: str = "", default: None = None) -> _T | None: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], provided: type[_T], name: str = "", *, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], provided: type[_T], name: str, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def lookup1(required: ISpecification | None, provided: type[_T], name: str = "", default: None = None) -> Callable[..., _T] | None: ...
    @overload
    def lookup1(required: ISpecification | None, provided: type[_T], name: str = "", *, default: _DefaultT) -> Callable[..., _T] | _DefaultT: ...
    @overload
    def lookup1(required: ISpecification | None, provided: type[_T], name: str, default: _DefaultT) -> Callable[..., _T] | _DefaultT: ...
    @overload
    def queryAdapter(object: object, provided: type[_T], name: str = "", default: None = None) -> _T | None: ...
    @overload
    def queryAdapter(object: object, provided: type[_T], name: str = "", *, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def queryAdapter(object: object, provided: type[_T], name: str, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def adapter_hook(object: object, provided: type[_T], name: str = "", default: None = None) -> _T | None: ...
    @overload
    def adapter_hook(object: object, provided: type[_T], name: str = "", *, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def adapter_hook(object: object, provided: type[_T], name: str, default: _DefaultT) -> _T | _DefaultT: ...
    def lookupAll(required: Sequence[ISpecification | None], provided: type[_T]) -> Sequence[tuple[str, Callable[..., _T]]]: ...
    def names(required: Sequence[ISpecification | None], provided: IInterface) -> Collection[str]: ...
    @overload
    def subscribe(required: Sequence[ISpecification | None], provided: None, value: Callable[..., object]) -> None: ...
    @overload
    def subscribe(required: Sequence[ISpecification | None], provided: type[_T], value: Callable[..., _T]) -> None: ...
    def subscribed(required: Sequence[ISpecification], provided: IInterface | None, subscriber: _CallableT) -> _CallableT | None: ...
    @overload
    def subscriptions(required: Sequence[ISpecification | None], provided: type[_T]) -> Sequence[Callable[..., _T]]: ...
    @overload
    def subscriptions(required: Sequence[ISpecification | None], provided: None) -> Sequence[Callable[..., object]]: ...
    @overload
    def subscribers(objects: Sequence[object], provided: type[_T]) -> Sequence[_T]: ...
    @overload
    def subscribers(objects: Sequence[object], provided: None) -> tuple[()]: ...

class ComponentLookupError(LookupError): ...

class IObjectEvent(Interface):
    object: Any

@implementer(IObjectEvent)
class ObjectEvent:
    object: Any
    def __init__(self, object: object) -> None: ...

class IComponentLookup(Interface):
    adapters: IAdapterRegistry
    utilities: IAdapterRegistry
    @overload
    def queryAdapter(object: object, interface: type[_T], name: str = "", default: None = None) -> _T | None: ...
    @overload
    def queryAdapter(object: object, interface: type[_T], name: str = "", *, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def queryAdapter(object: object, interface: type[_T], name: str, default: _DefaultT) -> _T | _DefaultT: ...
    def getAdapter(object: object, interface: type[_T], name: str = "") -> _T: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], interface: type[_T], name: str = "", default: None = None) -> _T | None: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], interface: type[_T], name: str = "", *, default: _DefaultT) -> _T | _DefaultT: ...
    @overload
    def queryMultiAdapter(objects: Sequence[object], interface: type[_T], name: str, default: _DefaultT) -> _T | _DefaultT: ...
    def getMultiAdapter(objects: Sequence[object], interface: type[_T], name: str = "") -> _T: ...
    def getAdapters(objects: Sequence[object], provided: type[_T]) -> Iterable[tuple[str, _T]]: ...
    @overload
    def subscribers(objects: Sequence[object], provided: type[_T]) -> Iterable[_T]: ...
    @overload
    def subscribers(objects: Sequence[object], provided: None) -> Iterable[Any]: ...
    def handle(*objects: Sequence[object]) -> None: ...
    # NOTE: We overwrite some of the stubs from Component, because
    #       they are not as smart about the default parameter
    @overload  # type:ignore[override]
    def queryUtility(
        self,
        provided: type[_I],
        name: str = ...,
    ) -> _I | None: ...
    @overload
    def queryUtility(
        self,
        provided: type[_I],
        name: str = ...,
        default: _T = ...
    ) -> _I | _T: ...
    @overload
    def queryUtility(
        self,
        provided: type[_T],
        name: str = ...,
        default: _I = ...
    ) -> _I: ...
    def getUtilitiesFor(interface: type[_T]) -> Iterable[tuple[str, _T]]: ...
    def getAllUtilitiesRegisteredFor(interface: type[_T]) -> Iterable[_T]: ...

class IRegistration(Interface):
    registry: IComponentRegistry
    name: str
    info: str

class IUtilityRegistration(IRegistration):
    factory: Callable[[], Any] | None
    component: Any
    provided: IInterface

class _IBaseAdapterRegistration(IRegistration):
    factory: Callable[..., Any]
    required: Sequence[ISpecification]
    provided: IInterface

class IAdapterRegistration(_IBaseAdapterRegistration): ...
class ISubscriptionAdapterRegistration(_IBaseAdapterRegistration): ...

class IHandlerRegistration(IRegistration):
    handler: Callable[..., object]
    required: Sequence[ISpecification]

class IRegistrationEvent(IObjectEvent): ...
@implementer(IRegistrationEvent)
class RegistrationEvent(ObjectEvent): ...

class IRegistered(IRegistrationEvent): ...
@implementer(IRegistered)
class Registered(RegistrationEvent): ...

class IUnregistered(IRegistrationEvent): ...
@implementer(IUnregistered)
class Unregistered(RegistrationEvent): ...

class IComponentRegistry(Interface):
    def registerUtility(component: object | None = None, provided: IInterface | None = None, name: str = "", info: str = "", event: bool = True, factory: Callable[[], object] | None = None) -> None: ...
    def unregisterUtility(component: object | None = None, provided: IInterface | None = None, name: str = "", factory: Callable[[], object] | None = None) -> bool: ...
    def registeredUtilities() -> Iterable[IUtilityRegistration]: ...
    def registerAdapter(factory: Callable[..., object], required: _Adapts | None = None, provided: IInterface | None = None, name: str = "", info: str = "", event: bool = True) -> None: ...
    def unregisterAdapter(factory: Callable[..., object] | None = None, required: _Adapts | None = None, provided: IInterface | None = None, name: str = "") -> bool: ...
    def registeredAdapters() -> Iterable[IAdapterRegistration]: ...
    def registerSubscriptionAdapter(factory: Callable[..., object], required: _Adapts | None = None, provided: IInterface | None = None, name: str = "", info: str = "", event: bool = True) -> None: ...
    def unregisterSubscriptionAdapter(factory: Callable[..., object] | None = None, required: _Adapts | None = None, provided: IInterface | None = None, name: str = "") -> bool: ...
    def registeredSubscriptionAdapters() -> Iterable[ISubscriptionAdapterRegistration]: ...
    def registerHandler(factory: Callable[..., object], required: _Adapts | None = None, name: str = "", info: str = "", event: bool = True) -> None: ...
    def unregisterHandler(factory: Callable[..., object] | None = None, required: _Adapts | None = None, name: str = "") -> bool: ...
    def registeredHandlers() -> Iterable[IHandlerRegistration]: ...

class IComponents(IComponentLookup, IComponentRegistry): ...
