from _typeshed import Incomplete
from collections.abc import Callable, Collection, Generator, Iterator, Sequence
from typing import Any, NoReturn, TypedDict, TypeVar, overload
from typing_extensions import Self
from weakref import WeakKeyDictionary, ref

from zope.interface.declarations import implementer
from zope.interface.exceptions import Invalid
from zope.interface.interfaces import IAttribute, IElement, IInterface, IMethod, ISpecification

__all__ = ["InterfaceClass", "Specification", "adapter_hooks"]

_T = TypeVar("_T")
_CallableT = TypeVar("_CallableT", bound=Callable[..., Any])

class _SignatureInfo(TypedDict):
    positional: Sequence[str]
    required: Sequence[str]
    varargs: str | None
    kwargs: str | None
    optional: dict[str, Any]

@implementer(IElement)
class Element:
    def __init__(self, __name__: str, __doc__: str = "") -> None: ...
    def getName(self) -> str | None: ...
    def getDoc(self) -> str: ...
    def getTaggedValue(self, tag: object) -> Any: ...
    @overload
    def queryTaggedValue(self, tag: object, default: None = None) -> Any | None: ...
    @overload
    def queryTaggedValue(self, tag: object, default: _T) -> Any | _T: ...
    def getTaggedValueTags(self) -> Collection[Any]: ...
    def setTaggedValue(self, tag: object, value: object) -> None: ...
    queryDirectTaggedValue = queryTaggedValue
    getDirectTaggedValue = getTaggedValue
    getDirectTaggedValueTags = getTaggedValueTags

class SpecificationBase:
    __slots__ = (
        "_implied",
        "_dependents",
        "_bases",
        "_v_attrs",
        "__iro__",
        "__sro__",
        "__weakref__",
    )
    __iro__: tuple[InterfaceClass, ...]
    __sro__: tuple[Specification, ...]
    def providedBy(self, ob: object) -> bool: ...
    def implementedBy(self, cls: type[object]) -> bool: ...
    def isOrExtends(self, interface: ISpecification) -> bool: ...
    __call__ = isOrExtends

class NameAndModuleComparisonMixin:
    def __lt__(self, other: NameAndModuleComparisonMixin) -> bool: ...
    def __le__(self, other: NameAndModuleComparisonMixin) -> bool: ...
    def __gt__(self, other: NameAndModuleComparisonMixin) -> bool: ...
    def __ge__(self, other: NameAndModuleComparisonMixin) -> bool: ...

class InterfaceBase(NameAndModuleComparisonMixin, SpecificationBase):
    __ibmodule__: str
    __name__: str
    def __init__(self, name: str | None = None, module: str | None = None) -> None: ...
    @overload
    def __call__(self, obj: object) -> Any: ...
    @overload
    def __call__(self, obj: object, alternate: _T) -> Any | _T: ...
    def __adapt__(self, obj: object) -> Any | None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

adapter_hooks: Incomplete

@implementer(ISpecification)
class Specification(SpecificationBase):
    __slots__ = ()
    @property
    def __bases__(self) -> tuple[Specification, ...]: ...
    @__bases__.setter
    def __bases__(self, value: tuple[Specification, ...]) -> None: ...
    __iro__: tuple[InterfaceClass, ...]
    __sro__: tuple[Specification, ...]
    def __init__(self, bases: tuple[Specification, ...] = ()) -> None: ...
    @property
    def dependents(self) -> WeakKeyDictionary[Specification, int]: ...
    def subscribe(self, dependent: ISpecification) -> None: ...
    def unsubscribe(self, dependent: ISpecification) -> None: ...
    def changed(self, originally_changed: ISpecification) -> None: ...
    def interfaces(self) -> Generator[InterfaceClass, None, None]: ...
    def extends(self, interface: ISpecification, strict: bool = True) -> bool: ...
    def weakref(self, callback: Callable[[ref[Self]], Any] | None = None) -> ref[Self]: ...
    @overload
    def get(self, name: str, default: None = None) -> Attribute | None: ...
    @overload
    def get(self, name: str, default: _T) -> Attribute | _T: ...

class _InterfaceMetaClass(type):
    def __new__(cls: type[_T], name: str | None, bases: tuple[type[object], ...], attrs: dict[str, Any]) -> _T: ...
    @property
    def __module__(cls) -> str: ...  # type: ignore[override]

# NOTE: Technically this is not a subclass of type but mypy only supports
#       metaclasses that derive from type and this is used as a metaclass
class _InterfaceClassBase(InterfaceBase, Specification, Element, type, metaclass=_InterfaceMetaClass):  # type: ignore[misc]
    __slots__ = ()

@implementer(IInterface)
class InterfaceClass(_InterfaceClassBase):
    __identifier__: str
    def __new__(cls: type[_T], name: str | None = None, bases: tuple[InterfaceClass, ...] = (), attrs: dict[str, Any] | None = None, __doc__: str | None = None, __module__: str | None = None) -> _T: ...
    def __init__(self, name: str | None, bases: tuple[InterfaceClass, ...] = (), attrs: dict[str, Any] | None = None, __doc__: str | None = None, __module__: str | None = None) -> None: ...
    def interfaces(self) -> Generator[InterfaceClass, None, None]: ...
    def getBases(self) -> tuple[Specification, ...]: ...
    def isEqualOrExtendedBy(self, other: IInterface) -> bool: ...
    def names(self, all: bool = False) -> Collection[str]: ...
    def __iter__(self) -> Iterator[str]: ...
    def namesAndDescriptions(self, all: bool = False) -> Collection[tuple[str, Attribute]]: ...
    def getDescriptionFor(self, name: str) -> Attribute: ...
    __getitem__ = getDescriptionFor
    def __contains__(self, name: str) -> bool: ...
    def direct(self, name: str) -> Attribute | None: ...
    @overload
    def queryDescriptionFor(self, name: str, default: None = None) -> Attribute | None: ...
    @overload
    def queryDescriptionFor(self, name: str, default: _T) -> Attribute | _T: ...
    def validateInvariants(self, obj: object, errors: list[Invalid] | None = None) -> None: ...
    def __reduce__(self) -> str: ...

class Interface(metaclass=InterfaceClass): ...

@implementer(IAttribute)
class Attribute(Element):
    interface: IInterface

@implementer(IMethod)
class Method(Attribute):
    positional: tuple[str, ...]
    required: tuple[str, ...]
    varargs: str | None
    kwargs: str | None
    optional: dict[str, Any]
    def __call__(self, *args: object, **kw: object) -> NoReturn: ...
    def getSignatureInfo(self) -> _SignatureInfo: ...
    def getSignatureString(self) -> str: ...

# NOTE: The following functions are defined here, but only exported
#       in zope.interface, rather than zope.interface.interface
#       They also all require special-casing in the plugin, since
#       the methods/attributes created this way are not part of the
#       structure that needs to be satisfied
def interfacemethod(func: _CallableT) -> _CallableT: ...
def invariant(call: Callable[[Any], object]) -> object: ...
def taggedValue(key: object, value: object) -> object: ...
