import numbers
from typing import Any, Literal, overload

from zope.interface import classImplements
from zope.interface.common import ABCInterface

class INumber(ABCInterface):
    def __hash__() -> int: ...
classImplements(numbers.Number, INumber)

class IComplex(INumber):
    real: numbers._RealLike
    imag: numbers._RealLike
    def __bool__() -> bool: ...
    def __add__(other: Any) -> numbers._ComplexLike: ...
    def __radd__(other: Any) -> numbers._ComplexLike: ...
    def __neg__() -> numbers._ComplexLike: ...
    def __pos__() -> numbers._ComplexLike: ...
    def __sub__(other: Any) -> numbers._ComplexLike: ...
    def __rsub__(other: Any) -> numbers._ComplexLike: ...
    def __mul__(other: Any) -> numbers._ComplexLike: ...
    def __rmul__(other: Any) -> numbers._ComplexLike: ...
    def __truediv__(other: Any) -> numbers._ComplexLike: ...
    def __rtruediv__(other: Any) -> numbers._ComplexLike: ...
    def __pow__(exponent: Any) -> numbers._ComplexLike: ...
    def __rpow__(base: Any) -> numbers._ComplexLike: ...
    def __abs__() -> numbers._RealLike: ...
    def conjugate() -> numbers._ComplexLike: ...
classImplements(numbers.Complex, IComplex)
classImplements(complex, IComplex)

class IReal(IComplex):
    imag: Literal[0]
    def __float__() -> float: ...
    def __trunc__() -> numbers._IntegralLike: ...
    def __floor__() -> numbers._IntegralLike: ...
    def __ceil__() -> numbers._IntegralLike: ...
    @overload
    def __round__(ndigits: None = None) -> numbers._IntegralLike: ...
    @overload
    def __round__(ndigits: int) -> numbers._RealLike: ...
    def __divmod__(other: Any) -> tuple[numbers._RealLike, numbers._RealLike]: ...
    def __rdivmod__(other: Any) -> tuple[numbers._RealLike, numbers._RealLike]: ...
    def __floordiv__(other: Any) -> numbers._RealLike: ...
    def __rfloordiv__(other: Any) -> numbers._RealLike: ...
    def __mod__(other: Any) -> numbers._RealLike: ...
    def __rmod__(other: Any) -> numbers._RealLike: ...
    def __lt__(other: Any) -> bool: ...
    def __le__(other: Any) -> bool: ...
    def conjugate() -> numbers._RealLike: ...
    # Not actually overridden at runtime,
    # but we override these in the stub to give them more precise return types:
    def __pos__() -> numbers._RealLike: ...
    def __neg__() -> numbers._RealLike: ...
classImplements(numbers.Real, IReal)
classImplements(float, IReal)

class IRational(IReal):
    numerator: numbers._IntegralLike
    denominator: numbers._IntegralLike
    def __float__() -> float: ...
classImplements(numbers.Rational, IRational)

class IIntegral(IRational):
    denominator: Literal[1]
    def __int__() -> int: ...
    def __index__() -> int: ...
    def __pow__(exponent: Any, modulus: Any | None = None) -> numbers._IntegralLike: ...
    def __lshift__(other: Any) -> numbers._IntegralLike: ...
    def __rlshift__(other: Any) -> numbers._IntegralLike: ...
    def __rshift__(other: Any) -> numbers._IntegralLike: ...
    def __rrshift__(other: Any) -> numbers._IntegralLike: ...
    def __and__(other: Any) -> numbers._IntegralLike: ...
    def __rand__(other: Any) -> numbers._IntegralLike: ...
    def __xor__(other: Any) -> numbers._IntegralLike: ...
    def __rxor__(other: Any) -> numbers._IntegralLike: ...
    def __or__(other: Any) -> numbers._IntegralLike: ...
    def __ror__(other: Any) -> numbers._IntegralLike: ...
    def __invert__() -> numbers._IntegralLike: ...
    def __pos__() -> numbers._IntegralLike: ...
    def __neg__() -> numbers._IntegralLike: ...
    def __abs__() -> numbers._IntegralLike: ...
    # NOTE: This really loose signature is necessary so we can register both
    #       `builtins.int` and `numbers.Integral`
    def __round__(ndigits: Any = ...) -> Any: ...
classImplements(numbers.Integral, IIntegral)
classImplements(int, IIntegral)
