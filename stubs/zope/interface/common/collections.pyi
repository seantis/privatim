from _typeshed import SupportsKeysAndGetItem
from collections import abc
from types import TracebackType
from typing import Any, TypeVar, overload

from zope.interface import classImplements
from zope.interface.common import ABCInterface

__all__ = [
    "IAsyncGenerator",
    "IAsyncIterable",
    "IAsyncIterator",
    "IAwaitable",
    "ICollection",
    "IContainer",
    "ICoroutine",
    "IGenerator",
    "IHashable",
    "IItemsView",
    "IIterable",
    "IIterator",
    "IKeysView",
    "IMapping",
    "IMappingView",
    "IMutableMapping",
    "IMutableSequence",
    "IMutableSet",
    "IReversible",
    "ISequence",
    "ISet",
    "ISized",
    "IValuesView",
]

_T = TypeVar("_T")
# TODO: Consider making these generic, even if they aren't at runtime

class IContainer(ABCInterface):
    def __contains__(x: Any, /) -> bool: ...
classImplements(abc.Container, IContainer)

class IHashable(ABCInterface):
    def __hash__() -> int: ...
classImplements(abc.Hashable, IHashable)

class IIterable(ABCInterface):
    def __iter__() -> abc.Iterator[Any]: ...
classImplements(abc.Iterable, IIterable)

class IIterator(IIterable):
    def __next__() -> Any: ...
classImplements(abc.Iterator, IIterator)

class IReversible(IIterable):
    def __reversed__() -> abc.Iterator[Any]: ...
classImplements(abc.Reversible, IReversible)

class IGenerator(IIterator):
    def send(value: Any, /) -> Any: ...
    @overload
    def throw(
        typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
    ) -> Any: ...
    @overload
    def throw(typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> Any: ...
    def close() -> None: ...
    def __iter__() -> abc.Generator[Any, Any, Any]: ...
classImplements(abc.Generator, IGenerator)

class ISized(ABCInterface):
    def __len__() -> int: ...
classImplements(abc.Sized, ISized)

class ICollection(ISized, IIterable, IContainer): ...
classImplements(abc.Collection, ICollection)

class ISequence(IReversible, ICollection):
    @overload
    def __getitem__(index: int) -> Any: ...
    @overload
    def __getitem__(index: slice) -> abc.Sequence[Any]: ...
    def index(value: Any, start: int = 0, stop: int = ...) -> int: ...
    def count(value: Any) -> int: ...
classImplements(abc.Sequence, ISequence)

class IMutableSequence(ISequence):
    def insert(index: int, value: Any) -> None: ...
    @overload
    def __getitem__(index: int) -> Any: ...
    @overload
    def __getitem__(index: slice) -> abc.MutableSequence[Any]: ...
    @overload
    def __setitem__(index: int, value: Any) -> None: ...
    @overload
    def __setitem__(index: slice, value: abc.Iterable[Any]) -> None: ...
    @overload
    def __delitem__(index: int) -> None: ...
    @overload
    def __delitem__(index: slice) -> None: ...
    def append(value: Any) -> None: ...
    def clear() -> None: ...
    def extend(values: abc.Iterable[Any]) -> None: ...
    def reverse() -> None: ...
    def pop(index: int = -1) -> Any: ...
    def remove(value: Any) -> None: ...
    def __iadd__(values: abc.Iterable[Any]) -> IMutableSequence: ...  # noqa: PYI034
classImplements(abc.MutableSequence, IMutableSequence)

class IByteString(ISequence): ...
classImplements(bytes, IByteString)
classImplements(bytearray, IByteString)
classImplements(memoryview, IByteString)

class ISet(ICollection):
    def _hash() -> int: ...
    def __le__(other: abc.Set[Any]) -> bool: ...
    def __lt__(other: abc.Set[Any]) -> bool: ...
    def __gt__(other: abc.Set[Any]) -> bool: ...
    def __ge__(other: abc.Set[Any]) -> bool: ...
    def __and__(other: abc.Set[Any]) -> ISet: ...
    def __or__(other: abc.Set[Any]) -> ISet: ...
    def __sub__(other: abc.Set[Any]) -> ISet: ...
    def __xor__(other: abc.Set[Any]) -> ISet: ...
    def __eq__(other: object) -> bool: ...
    def isdisjoint(other: abc.Iterable[Any]) -> bool: ...
classImplements(abc.Set, ISet)

class IMutableSet(ISet):
    def add(value: Any) -> None: ...
    def discard(value: Any) -> None: ...
    def clear() -> None: ...
    def pop() -> Any: ...
    def remove(value: Any) -> None: ...
    def __ior__(it: abc.Set[Any]) -> IMutableSet: ...  # noqa: PYI034
    def __iand__(it: abc.Set[Any]) -> IMutableSet: ...  # noqa: PYI034
    def __ixor__(it: abc.Set[Any]) -> IMutableSet: ...  # noqa: PYI034
    def __isub__(it: abc.Set[Any]) -> IMutableSet: ...  # noqa: PYI034
classImplements(abc.MutableSet, IMutableSet)

class IMapping(ICollection):
    def __getitem__(key: Any, /) -> Any: ...
    @overload
    def get(key: Any, /) -> Any | None: ...
    @overload
    def get(key: Any, /, default: _T) -> Any | _T: ...
    def items() -> abc.ItemsView[Any, Any]: ...
    def keys() -> abc.KeysView[Any]: ...
    def values() -> abc.ValuesView[Any]: ...
classImplements(abc.Mapping, IMapping)

class IMutableMapping(IMapping):
    def __setitem__(key: Any, value: Any, /) -> None: ...
    def __delitem__(key: Any, /) -> None: ...
    def clear() -> None: ...
    @overload
    def pop(key: Any, /) -> Any: ...
    @overload
    def pop(key: Any, /, default: _T) -> Any | _T: ...
    def popitem() -> tuple[Any, Any]: ...
    @overload
    def setdefault(key: Any, default: None = None) -> Any | None: ...
    @overload
    def setdefault(key: Any, default: _T) -> Any | _T: ...
    @overload
    def update(m: SupportsKeysAndGetItem[Any, Any], /) -> None: ...
    @overload
    def update(m: SupportsKeysAndGetItem[str, Any], /, **kwargs: Any) -> None: ...
    @overload
    def update(m: abc.Iterable[tuple[Any, Any]], /) -> None: ...
    @overload
    def update(m: abc.Iterable[tuple[str, Any]], /, **kwargs: Any) -> None: ...
    @overload
    def update(**kwargs: Any) -> None: ...
classImplements(abc.MutableMapping, IMutableMapping)

class IMappingView(ISized): ...
classImplements(abc.MappingView, IMappingView)

class IItemsView(IMappingView, ISet):
    def __and__(other: abc.Iterable[Any]) -> abc.Set[tuple[Any, Any]]: ...
    def __rand__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __or__(other: abc.Iterable[Any]) -> set[tuple[Any, Any]]: ...
    def __ror__(other: abc.Iterable[Any]) -> set[tuple[Any, Any]]: ...
    def __sub__(other: abc.Iterable[Any]) -> set[tuple[Any, Any]]: ...
    def __rsub__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __xor__(other: abc.Iterable[Any]) -> set[tuple[Any, Any]]: ...
    def __rxor__(other: abc.Iterable[Any]) -> set[tuple[Any, Any]]: ...
classImplements(abc.ItemsView, IItemsView)

class IKeysView(IMappingView, ISet):
    def __and__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __rand__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __or__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __ror__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __sub__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __rsub__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __xor__(other: abc.Iterable[Any]) -> set[Any]: ...
    def __rxor__(other: abc.Iterable[Any]) -> set[Any]: ...
classImplements(abc.KeysView, IKeysView)

class IValuesView(IMappingView, ICollection): ...
classImplements(abc.ValuesView, IValuesView)

class IAwaitable(ABCInterface):
    def __await__() -> abc.Generator[Any, Any, Any]: ...
classImplements(abc.Awaitable, IAwaitable)

class ICoroutine(IAwaitable):
    __name__: str
    __qualname__: str
    def send(value: Any, /) -> Any: ...
    @overload
    def throw(
        typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
    ) -> Any: ...
    @overload
    def throw(typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> Any: ...
    def close() -> None: ...
classImplements(abc.Coroutine, ICoroutine)

class IAsyncIterable(ABCInterface):
    def __aiter__() -> abc.AsyncIterator[Any]: ...
classImplements(abc.AsyncIterable, IAsyncIterable)

class IAsyncIterator(IAsyncIterable):
    def __anext__() -> abc.Awaitable[Any]: ...
classImplements(abc.AsyncIterator, IAsyncIterator)

# TODO: These Awaitables can be expanded to Coroutine eventually
class IAsyncGenerator(IAsyncIterator):
    def asend(value: Any, /) -> abc.Awaitable[Any]: ...
    @overload
    def athrow(
        typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /
    ) -> abc.Awaitable[Any]: ...
    @overload
    def athrow(
        typ: BaseException, val: None = None, tb: TracebackType | None = None, /
    ) -> abc.Awaitable[Any]: ...
    def aclose() -> abc.Awaitable[None]: ...
classImplements(abc.AsyncGenerator, IAsyncGenerator)
