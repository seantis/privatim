from sqlalchemy import select
from sqlalchemy.orm import selectinload
import re
from pathlib import Path
from webtest import Upload
from webtest.forms import File # Keep for webtest version
import transaction
import pytest
from playwright.sync_api import Page, expect
from sqlalchemy.orm import Session

from privatim.models import SearchableFile, Consultation, Meeting, WorkingGroup, User
from privatim.models.meeting import AgendaItem
from privatim.views.search import SearchCollection
from tests.shared.utils import (
    create_consultation, hash_file, create_meeting_with_agenda_items
)

# File actions automatically generated by UploadMultipleField 
# Only tested if one file is already uploaded
file_actions = {
    'keep': 'files-0-0',
    'delete': 'files-0-1',
    'replace': 'files-0-2'
}

# ======= Client/View Integration Tests =======

def test_search_integration_flow(client, pdf_vemz, docx):
    """
    Tests the full search flow via the web client, including:
    - Searching for content within PDF and DOCX files attached to a
    Consultation.
    - Verifying highlighted search terms in results.
    - Checking file download links.
    - Adding multiple files to a consultation.
    """
    # search in Files [x]
    # search in Consultation [x]
    # search in AgendaItem [ ]

    client.login_admin()

    page = client.get('/consultations')

    page = page.click('Vernehmlassung Erfassen')
    page.form['title'] = 'test'
    page.form.submit()

    page = client.get('/consultations')
    page = page.click('Vernehmlassung Erfassen')
    page.form['title'] = 'The test title'
    page.form['description'] = 'the description'
    page.form['recommendation'] = 'the recommendation'
    page.form['evaluation_result'] = 'the evaluation result'
    page.form['decision'] = 'the decision'
    page.form['status'] = 'Created'
    page.form['secondary_tags'] = ['AG', 'ZH']
    pdf_name, pdf_bytes = pdf_vemz
    page.form['files'] = Upload(pdf_name, pdf_bytes)
    page = page.form.submit().follow()
    client.get('/')

    client.skip_n_forms = 0
    search_form = page.forms['search']
    search_form['term'] = 'Sehr geehrte Damen und Herren'
    page = search_form.submit().follow()
    file_search_result = page.pyquery(
        'div.search-result-headline'
    )[0].text_content()
    # test the section from file is displayed in headline
    assert (
        'Sehr geehrte Damen und Herren Wir danken Ihnen für die '
        'Gelegenheit, zum Vorentwurf'
    ) in file_search_result

    # test we have linked to the file
    file_link = page.pyquery('a.search-result-link')[0]
    response = client.get(file_link.get('href'))
    downloaded_file_bytes = response.body
    original_hash = hash_file(pdf_bytes)
    downloaded_hash = hash_file(downloaded_file_bytes)
    assert original_hash == downloaded_hash, 'File integrity check failed'

    consultation = client.db.scalars(
        select(Consultation)
        .where(Consultation.title == 'The test title')
        .options(selectinload(Consultation.files))
    ).first()

    page = client.get(f'/consultations/{consultation.id}/edit')
    assert 'Vernehmlassung bearbeiten' in page
    # page.form['file-1'] = Upload

    # Note: This kind of depends on implementation detail of the naming of
    # the id's of these fields.
    # radio boxes are:
    # keep = files-0-0
    # delete = files-0-1
    # replace = files-0-2
    # first upload field = files-0

    # "Upload additional files" field has the id 'files'
    # Let's upload the docx additionally to the pdf using the option
    # "Upload additional files" of UploadMultipleFilesWithORMSupport
    docx_name, docx_bytse = docx
    form = page.forms[1]
    form['files'] = Upload(docx_name, docx_bytse)
    page = form.submit().follow()

    search_form = page.forms['search']
    search_form['term'] = 'more text here'
    page = search_form.submit().follow()
    docx_search_result = page.pyquery(
        'div.search-result-headline'
    )[0].text_content()
    assert 'TEST' in docx_search_result
    assert 'more text here' in docx_search_result

    # Fetch the new consultation from the database


@pytest.mark.skip('AgendaItem search somehow does not work in test, but if'
                  'tested manually works fine. There is something different'
                  'in fulltext search in the test')
def test_search_agenda_item_integration(client):
    """ Tests searching for content within an AgendaItem. """
    client.login_admin()

    # Create a meeting with an agenda item
    transaction.begin()
    agenda_item_data = [{
        'title': 'Agenda Item Alpha',
        'description': 'Discussion about project Alpha progress.'
    }]
    create_meeting_with_agenda_items(
        agenda_items=agenda_item_data, session=client.db
    )
    transaction.commit()
    session = client.db
    assert session.query(AgendaItem).count() == 1

    # Go to a page with the search bar (e.g., dashboard)
    # Follow the redirect from '/'
    page = client.get('/').follow()

    # Perform search
    client.skip_n_forms = 0
    search_form = page.forms['search']
    search_form['term'] = 'Alpha'
    page = search_form.submit().follow()
    assert 'Es wurden keine Ergebnisse gefunden' not in page

    # Verify search result
    assert 'Agenda Item Alpha' in page

def test_search_file_update_integration(client, pdf_vemz, pdf_full_text):
    """
    Tests searching after replacing a file in a Consultation using webtest.
    Ensures new content is found and old content is not.
    """
    client.login_admin()

    # 1. Create Consultation with initial PDF
    page = client.get('/consultations')
    page = page.click('Vernehmlassung Erfassen')
    page.form['title'] = 'Consultation 1'
    pdf_name_initial, pdf_bytes_initial = pdf_vemz
    page.form['files'] = Upload(pdf_name_initial, pdf_bytes_initial)
    page = page.form.submit().follow()
    consultation_id = page.request.url.split('/')[-1]

    # 2. Search for initial content
    search_form = page.forms['search']
    search_form['term'] = 'Sehr geehrte Damen und Herren'
    search_page = search_form.submit().follow()
    assert len(search_page.pyquery('.search-result-link')) == 1
    headline_text = search_page.pyquery(
        '.search-result-headline'
    ).text()
    normalized_headline = ' '.join(headline_text.split())
    assert 'Sehr geehrte Damen und Herren' in normalized_headline

    # 3. Edit Consultation and replace the file
    page = client.get(f'/consultations/{consultation_id}/edit')
    form = page.forms[1]
    form['title'] = 'Cons 2'
    pdf_name_new, pdf_bytes_new = pdf_full_text

    # files-0-0 is keep
    # files-0-1 is delete
    # files-0-2 is 'replace'

    # every other way of  setting the 'replace' doesn't work 
    # webtest gets confused otherwise due to same name
    page.form.get('files-0', 0).value = 'replace'
    page.form.get('files-0', 1).value = Upload(pdf_name_new, pdf_bytes_new)

    page = form.submit().follow()
    assert page.status_code == 200 
    assert 'Vernehmlassung erfolgreich bearbeitet' in page

    # Verify file replacement in DB
    updated_consultation = client.db.scalars(
        select(Consultation)
        .where(Consultation.title == 'Cons 2')
        .options(selectinload(Consultation.files))
    ).one()

    assert len(updated_consultation.files) == 1
    assert updated_consultation.files[0].filename == pdf_name_new

    # 4. Search for NEW content
    search_form = page.forms['search']
    search_form['term'] = 'full text search'
    search_page_new = search_form.submit().follow()
    assert 'fulltext_search.pdf' in search_page_new
    assert len(search_page_new.pyquery('.search-result-link')) == 1

    # 5. Search for OLD content (should NOT be found)
    search_form = page.forms['search']
    search_form['term'] = 'Sehr geehrte Damen und Herren'
    search_page_old = search_form.submit().follow()
    headline_text_old = search_page_old.pyquery(
        '.search-result-headline'
    ).text()
    normalized_headline_old = ' '.join(headline_text_old.split())
    assert 'Sehr geehrte Damen und Herren' not in normalized_headline_old, \
        'Old PDF content should not be found after replacement'
    assert len(search_page_old.pyquery('.search-result-link')) == 0, \
        'Expected zero file results for old PDF content'


def test_search_meeting_file_update_integration(
        client, pdf_vemz, pdf_full_text
):
    """
    Tests searching after replacing a file attached to a Meeting.
    Ensures new content is found and old content is not.
    """
    client.login_admin()
    session: Session = client.db

    # Setup: Create a WorkingGroup and a User
    transaction.begin()
    creator = session.query(User).filter_by(username='admin').one()
    wg = WorkingGroup(name='Test WG', creator=creator)
    session.add(wg)
    session.flush() # Flush to get wg.id
    transaction.commit()

    # 1. Create Meeting with initial PDF
    transaction.begin()
    pdf_name_initial, pdf_bytes_initial = pdf_vemz
    initial_file = SearchableFile(
        filename=pdf_name_initial, content=pdf_bytes_initial
    )
    meeting = Meeting(
        name='Meeting 1',
        time=datetime.utcnow(),
        attendees=[creator],
        working_group=wg,
        creator=creator
    )
    # Manually associate file as the form does
    initial_file.meeting = meeting
    session.add(meeting)
    session.add(initial_file)
    transaction.commit()

    # Fetch the meeting page to get the search form
    page = client.get(f'/meetings/{meeting.id}')

    # 2. Search for initial content
    search_form = page.forms['search']
    search_form['term'] = 'Sehr geehrte Damen und Herren'
    search_page = search_form.submit().follow()
    assert len(search_page.pyquery('.search-result-link')) == 1
    headline_text = search_page.pyquery(
        '.search-result-headline'
    ).text()
    normalized_headline = ' '.join(headline_text.split())
    assert 'Sehr geehrte Damen und Herren' in normalized_headline
    assert meeting.name in search_page.pyquery('.search-result-title').text()

    # 3. Edit Meeting and replace the file
    page = client.get(f'/meetings/{meeting.id}/edit')
    form = page.forms[1] # Assuming the second form is the edit form
    form['name'] = 'Meeting 1 Edited'
    pdf_name_new, pdf_bytes_new = pdf_full_text

    # Use the same file replacement logic
    form.get('files-0', 0).value = 'replace'
    form.get('files-0', 1).value = Upload(pdf_name_new, pdf_bytes_new)

    page = form.submit().follow()
    assert page.status_code == 200
    assert 'Sitzung erfolgreich bearbeitet' in page

    # Verify file replacement in DB
    updated_meeting = session.scalars(
        select(Meeting)
        .where(Meeting.id == meeting.id)
        .options(selectinload(Meeting.files))
    ).one()

    assert len(updated_meeting.files) == 1
    assert updated_meeting.files[0].filename == pdf_name_new
    assert updated_meeting.name == 'Meeting 1 Edited'

    # 4. Search for NEW content
    search_form = page.forms['search']
    search_form['term'] = 'full text search'
    search_page_new = search_form.submit().follow()
    assert 'fulltext_search.pdf' in search_page_new
    assert len(search_page_new.pyquery('.search-result-link')) == 1
    assert updated_meeting.name in search_page_new.pyquery(
        '.search-result-title'
    ).text()


    # 5. Search for OLD content (should NOT be found)
    search_form = page.forms['search']
    search_form['term'] = 'Sehr geehrte Damen und Herren'
    search_page_old = search_form.submit().follow()
    headline_text_old = search_page_old.pyquery(
        '.search-result-headline'
    ).text()
    normalized_headline_old = ' '.join(headline_text_old.split())
    assert 'Sehr geehrte Damen und Herren' not in normalized_headline_old, \
        'Old PDF content should not be found after replacement'
    assert len(search_page_old.pyquery('.search-result-link')) == 0, \
        'Expected zero file results for old PDF content'


# ======= Test SearchCollection Directly =======

def test_search(session, pdf_vemz):
    # Create a consultation with an attached pdf:
    setup_search_scenario(pdf_vemz, session)

    query = 'grundsätzlichen Fragen:'
    collection: SearchCollection = SearchCollection(
        term=query, session=session
    )
    collection.do_search()

    for result in collection.results:
        if result.type == 'SearchableFile':
            first_item = next(iter(result.headlines.values()))
            assert ('grundsätzlichen</mark> <mark>Fragen</mark>:' in
                    first_item), 'Highlighting tags missing'


def setup_search_scenario(pdf_to_search, session):
    documents = [SearchableFile(*pdf_to_search)]
    consultation = create_consultation(documents=documents)
    session.add(consultation)
    session.flush()


from datetime import datetime # Add datetime import
